I DON'T THINK THIS WORKS.

Shared Variable:

L: contains ownerId of the tail of the lock

Local Variables:

trigger: boolean
waiter: Id of next proc waiting for lock
myID: my thread ID

init:
{
	trigger = 0;
	next = nil
	waiter = nil;
}

acquire:
{
  if (L == nil)			// see if lock is free?
     L = myID			// try and grab it
  
  if (L != myID && trigger == 0) {		// did I get it?
     // trigger = 0;		// No, so get setup to wait for it
     sendI(&addme, &L, myID);
     while (trigger == 0) spin;
     // someone told me I have the lock
  }
  // I have the lock
}

release:
{
  DUI
  if (waiter != nil) {
    next = waiter;
    waiter = nil;
    next->trigger = 1;
  } else if (trigger == 1) { // prevent malicious immature release
  	L = nil;
  }
  trigger = 0;	// prevent double release
  EUI
}

addme(askId)
{
  assert(L != nil);
  DUI
    if (L != myId) {
      sendI(addme, &L, askId);
    } else {
      waiter = askId;
      L = askId;
    }
  EUI
}


Questions:
- Who can update L?
- Is it possible for more than on thread to have the ability to update L?
- Deadlock possible?
- Is it fair?
- Is it fast when not locked?
- worst case network traffic?  What is the condition?
- Do we need fences? atomic operations?




